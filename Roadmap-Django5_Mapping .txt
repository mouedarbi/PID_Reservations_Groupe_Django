Projet Réservations – Django 5.1 Roadmap
Prérequis : avoir terminé le kit de démarrage Roadmap Django 5 dans lequel se trouve les chapitres 1 à 4.
Chapitre 5 – Modéliser les données
Base de données : tables et entités
 
Nous allons réaliser le mapping relationnel des tables de la base de données en définissant les classes Python correspondantes. Il s’agit de la couche modèle du design pattern MVT. Cela nous permettra de manipuler des objets au moyen de l’ORM de Django. Nous commencerons par les tables simples. Dans les chapitres suivants, nous nous occuperons des tables possédant une clé étrangère de façon à réaliser les relations entre elles.

A vous de jouer !
•	Répétez ces opérations pour les relations entre les modèles 
Location  Show,
Location  Representation,
Show  Representation,
Show  Review et 
User  Review.
Notez qu’il y a deux références (clés étrangères) dans les tables représentations et reviews.
.1.	Créez chaque modèle avec les relations ManyToOne
.2.	Générez et exécutez les migrations progressivement après chaque nouveau modèle
.3.	Ajoutez des données initiales de test sans oublier de spécifier une clé naturelle en guise de référence pour la classe secondaire 
.4.	Sérialisez les données initiales de test au format JSON
.5.	Testez le bon chargement des données test dans la table
.6.	Tester les modèles et leurs relations en ligne de commande
.7.	[facultatif] Créez les vues, les templates  (index et show) et définissez les routes
•	Versionnez le projet au fur et à mesure
Bravo!
 
Solution partielle
Solution pour la relation Location –  Show
Mapping relationnel, migration et données test
La classe Location est en relation many-to-one avec la classe Show. En effet, un lieu peut être le lieu de création de plusieurs spectacles. Tandis qu’un spectacle est créé dans un seul lieu.
•	Créer le modèle Show (et sa relation avec le modèle Location)
Dans le module models, nous importons tout des modules show.
reservations\catalogue\models\__init__.py
from .artist import *
from .user_meta import *
from .type import *
from .locality import *
from .price import *
from .location import *
from .reservation import *
from .show import *

Créez un fichier de modèle catalogue/models/show.py. Définissez la classe Show, ainsi que ses propriétés. Ensuite, précisez le nom de la table au moyen de la métadonnée db_table.
catalogue\models\show.py
from django.db import models
from .location import *

# Create your models here.
class Show(models.Model):
    slug = models.CharField(max_length=60, unique=True)
    title = models.CharField(max_length=255)
    description = models.TextField(max_length=255, null=True)
    poster_url = models.CharField(max_length=255, null=True)
    duration = models.PositiveSmallIntegerField(null=True)
    created_in = models.PositiveSmallIntegerField(auto_now_add=True)
    location = models.ForeignKey(Location, on_delete=models.SET_NULL, null=True, related_name='shows')
    bookable = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(null=True)
    
    def __str__(self):
        return self.title
    
    class Meta:
        db_table = "shows"

Notez la contrainte d’unicité pour le champ slug et la clé étrangère location. Pour la relation inverse, nous nommons shows la propriété relative dans le modèle Location. Cela permettra d’écrire location.shows pour obtenir les spectacles qui se donnent dans ce lieu. Notez la contrainte d’intégrité on_delete définie à SET_NULL car lorsqu’un lieu est supprimé nous ne voulons ni empêcher cette suppression, ni supprimer en cascade les spectacles créés dans ce lieu.
•	Créer les migrations
py manage.py makemigrations catalogue
Vérifiez le fichier généré catalogue/migrations/0007_show.py :
catalogue/migrations/0007_show.py 
# Generated by Django 5.1.2 on 2025-01-05 11:55

import django.db.models.deletion
from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ('catalogue', '0006_reservation_locality_unique_postal_code_locality_and_more'),
    ]

    operations = [
        migrations.CreateModel(
            name='Show',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('slug', models.CharField(max_length=60, unique=True)),
                ('title', models.CharField(max_length=255)),
                ('description', models.TextField(max_length=255, null=True)),
                ('poster_url', models.CharField(max_length=255, null=True)),
                ('duration', models.PositiveSmallIntegerField(null=True)),
                ('created_in', models.PositiveSmallIntegerField()),
                ('bookable', models.BooleanField(default=True)),
                ('location', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='shows', to='catalogue.location')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(null=True)),
            ],
            options={
                'db_table': 'shows',
            },
        ),
    ]


•	Exécuter les migrations
python manage.py migrate
Dans la base de données, la table shows a été créée.
Tester les modèles en ligne de commande
14.	Tester nos modèles de données avec le shell de Django
Pour tester l’accès aux données et les relations, nous allons utiliser les méthodes de l’ORM de Django dans le shell de Django. Pensez à utiliser les touches flèche haut et flèche bas pour parcourir l’historique de vos commandes.
https://docs.djangoproject.com/fr/5.1/topics/db/queries/
py manage.py shell

from catalogue.models import Location, Show
from django.utils.text import slugify

delvaux = Location.objects.filter(slug="espace-delvaux-la-venerie").first()
dexia = Location.objects.filter(slug="dexia-art-center").first()
samaritaine = Location.objects.filter(slug="la-samaritaine").first()

slug = slugify("Ayiti")
show = Show(slug=slug,location=delvaux,title="Ayiti",created_in=2010)
show.save()

slug = slugify("Cible mouvante")
show = Show(slug=slug,location=dexia,title="Cible mouvante",created_in=2012)
show.save()

slug = slugify("Ceci n'est pas un chanteur belge")
show = Show(slug=slug,title="Ceci n'est pas un chanteur belge",created_in=2014)
show.save()

slug = slugify("Manneke… !")
show = Show(slug=slug,location=samaritaine,title="Manneke… !" ,created_in=2011)
show.save()

Show.objects.all()
Nous commençons par récupérer les lieux dont nous avons besoin. Ensuite, nous générons un slug avec l’utilitaire slugify importé de django.utils.text. Nous créons une instance de chaque spectacle (Show) en renseignant les propriétés slug et location. Puis, nous persistons l’objet dans la base de données. Enfin, nous affichons tous les spectacles créés.
ayiti = Show.objects.filter(slug='ayiti').first()
ayiti.location

dexia.shows.all()

Show.objects.filter(location=dexia)

exit()
Pour tester la relation many-to-one, nous recherchons le spectacle dont le slug est « ayiti ». Ensuite, nous affichons son lieu de création. Inversement, nous affichons tous les spectacles créés dans le lieu Dexia Art Center.
Si toutes les commandes testées dans Django Shell fonctionnent, le mapping relationnel est correct.
•	Versionner le projet
git status
git add .
git commit -m "Modèle Show +Relation ManyToOne with Location"
git push
Données de test
Location hasMany Show
•	Insérer un jeu de données de test dans la table
.1.	Exporter des données initiales pour le modèle (fixtures)
Nous avions déjà créé des instances de réservations lors de nos tests. Vous pouvez en créer davantage si nécessaire. À présent, nous exportons la table shows en un fichier de fixtures :
py -Xutf8 manage.py dumpdata catalogue.show --indent=2 > catalogue\fixtures\shows.json
Voilà, le fichier a été créé.
reservations\catalogue\fixtures\shows.json
[
{
  "model": "catalogue.show",
  "pk": 1,
  "fields": {
    "slug": "ayiti",
    "title": "Ayiti",
    "description": null,
    "poster_url": null,
    "duration": null,
    "created_in": 2010,
    "location": 4,
    "bookable": true,
    "created_at": "2025-01-07T17:41:03.509Z",
    "updated_at": null
  }
},
{
  "model": "catalogue.show",
  "pk": 2,
  "fields": {
    "slug": "cible-mouvante",
    "title": "Cible mouvante",
    "description": null,
    "poster_url": null,
    "duration": null,
    "created_in": 2012,
    "location": 5,
    "bookable": true,
    "created_at": "2025-01-07T17:41:15.554Z",
    "updated_at": null
  }
},
{
  "model": "catalogue.show",
  "pk": 3,
  "fields": {
    "slug": "ceci-nest-pas-un-chanteur-belge",
    "title": "Ceci n'est pas un chanteur belge",
    "description": null,
    "poster_url": null,
    "duration": null,
    "created_in": 2014,
    "location": null,
    "bookable": true,
    "created_at": "2025-01-07T17:41:15.585Z",
    "updated_at": null
  }
},
{
  "model": "catalogue.show",
  "pk": 4,
  "fields": {
    "slug": "manneke",
    "title": "Manneke… !",
    "description": null,
    "poster_url": null,
    "duration": null,
    "created_in": 2011,
    "location": 6,
    "bookable": true,
    "created_at": "2025-01-07T17:41:40.894Z",
    "updated_at": null
  }
}
]


•	Définir des références naturelles pour les relations
https://docs.djangoproject.com/fr/5.1/topics/serialization/#natural-keys
Tout cela fonctionne bien mais remarquons que la relation entre chaque objet Show et sa Location est représentée par la clé primaire. Ce type de référence manque de lisibilité.
//…
{
  "model": "catalogue.show",
  "pk": 1,
  "fields": {
    "slug": "ayiti",
    "title": "Ayiti",
    "description": null,
    "poster_url": null,
    "duration": null,
    "created_in": 2010,
    "location": 4,
    "bookable": true,
    "created_at": "2025-01-07T17:41:03.509Z",
    "updated_at": null
  }
},
//…
Pour ajouter la capacité de clé naturelle à nos modèles, il suffit de leur définir un gestionnaire par défaut avec une méthode get_by_natural_key(). Dans le cas du modèle Location, nous pouvons utiliser le slug puisqu’il est censé être unique, ou le site web, voire la combinaison des deux attributs.
Modifions le modèle Location :
reservations\catalogue\models\location.py
from django.db import models
from .locality import *

class LocationManager(models.Manager):
    def get_by_natural_key(self, slug, website):
        return self.get(slug=slug, website=website)

class Location(models.Model):
    slug = models.CharField(max_length=60, unique=True)
    designation = models.CharField(max_length=60)
    address = models.CharField(max_length=255)
    locality = models.ForeignKey(Locality, 
        on_delete=models.RESTRICT, null=True, related_name='locations')
    website = models.CharField(max_length=255, null=True)
    phone = models.CharField(max_length=30, null=True)

    objects = LocationManager()

    def __str__(self):
        return self.designation

    class Meta:
        db_table = "locations"
        constraints = [
            models.UniqueConstraint(
                fields=["slug", "website"],
                name="unique_slug_website",
            ),
        ]
    
    def natural_key(self):
        return (self.slug, self.website)


.1.	Exporter des données initiales pour le modèle (fixtures)
Nous pouvons ensuite exécuter le dump des données initiales en ajoutant l’option --natural-foreign :
py -Xutf8 manage.py dumpdata catalogue.show --indent=2 --natural-foreign > catalogue\fixtures\shows.json
reservations\catalogue\fixtures\shows.json
[
{
  "model": "catalogue.show",
  "pk": 1,
  "fields": {
    "slug": "ayiti",
    "title": "Ayiti",
    "description": null,
    "poster_url": null,
    "duration": null,
    "created_in": 2010,
    "location": [
      "espace-delvaux-la-venerie",
      "https://www.lavenerie.be"
    ],
    "bookable": true,
    "created_at": "2025-01-07T17:41:03.509Z",
    "updated_at": null
  }
},
{
  "model": "catalogue.show",
  "pk": 2,
  "fields": {
    "slug": "cible-mouvante",
    "title": "Cible mouvante",
    "description": null,
    "poster_url": null,
    "duration": null,
    "created_in": 2012,
    "location": [
      "dexia-art-center",
      null
    ],
    "bookable": true,
    "created_at": "2025-01-07T17:41:15.554Z",
    "updated_at": null
  }
},
{
  "model": "catalogue.show",
  "pk": 3,
  "fields": {
    "slug": "ceci-nest-pas-un-chanteur-belge",
    "title": "Ceci n'est pas un chanteur belge",
    "description": null,
    "poster_url": null,
    "duration": null,
    "created_in": 2014,
    "location": null,
    "bookable": true,
    "created_at": "2025-01-07T17:41:15.585Z",
    "updated_at": null
  }
},
{
  "model": "catalogue.show",
  "pk": 4,
  "fields": {
    "slug": "manneke",
    "title": "Manneke… !",
    "description": null,
    "poster_url": null,
    "duration": null,
    "created_in": 2011,
    "location": [
      "la-samaritaine",
      "http://www.lasamaritaine.be/"
    ],
    "bookable": true,
    "created_at": "2025-01-07T17:41:40.894Z",
    "updated_at": null
  }
}
]


Nous pouvons remarquer à présent qu’au lieu d’avoir l’id de clé étrangère pour la location, nous avons le tuple slug et website à la place, ce qui améliore la lisibilité de nos données de test.
    "location": [
      "espace-delvaux-la-venerie",
      "https://www.lavenerie.be"
    ],

À présent, modifiez le fichier pour ajouter les données manquantes (description, poster_url, price) :
reservations\catalogue\fixtures\shows.json
[
{
  "model": "catalogue.show",
  "pk": 1,
  "fields": {
    "slug": "ayiti",
    "title": "Ayiti",
    "description": "Un homme est bloqué à l'aéroport.\n Questionné par les douaniers, il doit alors justifier son identité, et surtout prouver qu'il est haïtien - Qu'est-ce qu'être haïtien ?",
    "poster_url": "ayiti.jpg",
    "duration": 90,
    "created_in": 2010,
    "location": [
      "espace-delvaux-la-venerie",
      "https://www.lavenerie.be"
    ],
    "bookable": true,
    "created_at": "2025-01-07T17:41:03.509Z",
    "updated_at": null
  }
},
{
  "model": "catalogue.show",
  "pk": 2,
  "fields": {
    "slug": "cible-mouvante",
    "title": "Cible mouvante",
    "description": "Dans ce « thriller d'anticipation », des adultes semblent alimenter et véhiculer une crainte féroce envers les enfants âgés entre 10 et 12 ans.",
    "poster_url": "cible.jpg",
    "duration": 90,
    "created_in": 2012,
    "location": [
      "dexia-art-center",
      null
    ],
    "bookable": true,
    "created_at": "2025-01-07T17:41:15.554Z",
    "updated_at": null
  }
},
{
  "model": "catalogue.show",
  "pk": 3,
  "fields": {
    "slug": "ceci-nest-pas-un-chanteur-belge",
    "title": "Ceci n'est pas un chanteur belge",
    "description": "Non peut-être ?!\nEntre Magritte (pour le surréalisme comique) et Maigret (pour le réalisme mélancolique), ce dixième opus semalien propose quatorze nouvelles chansons mêlées à de petits textes humoristiques et à quelques fortes images poétiques.",
    "poster_url": "ceci-nest-pas-un-chanteur-belge.jpg",
    "duration": 90,
    "created_in": 2014,
    "location": null,
    "bookable": false,
    "created_at": "2025-01-07T17:41:15.585Z",
    "updated_at": null
  }
},
{
  "model": "catalogue.show",
  "pk": 4,
  "fields": {
    "slug": "manneke",
    "title": "Manneke… !",
    "description": "A tour de rôle, Pierre se joue de ses oncles, tantes, grands-parents et surtout de sa mère.",
    "poster_url": "manneke.jpg",
    "duration": 90,
    "created_in": 2011,
    "location": [
      "la-samaritaine",
      "http://www.lasamaritaine.be/"
    ],
    "bookable": true,
    "created_at": "2025-01-07T17:41:40.894Z",
    "updated_at": null
  }
}
]


Enfin, nous pouvons inversement exécuter le chargement des données initiales vers la base de données :
0.1.	Exécutez le chargement des fixtures :
py manage.py loaddata shows.json
Vous pouvez vérifier dans la table locations la bonne insertion des mêmes données.
 
1.	Versionner le projet
git status
git add .
git commit -m "Données initiales Show avec clés naturelles Location"
git push
Vues et templates
21.1.	Définir une route
Modifiez le fichier urls.py de l’application catalogue de façon à définir les routes location-index et location-show.
catalogue/urls.py
"""reservations.catalogue URL Configuration
"""
from django.urls import path

from . import views

app_name='catalogue'

urlpatterns = [
    path('artist/', views.artist.index, name='artist-index'),
    path('artist/<int:artist_id>', views.artist.show, name='artist-show'),
    path('artist/edit/<int:artist_id>', views.artist.edit, name='artist-edit'),
    path('artist/create', views.artist.create, name='artist-create'),
    path('artist/delete/<int:artist_id>', views.artist.delete, name='artist-delete'),
    path('type/', views.type.index, name='type-index'),
    path('type/<int:type_id>', views.type.show, name='type-show'),
    path('locality/', views.locality.index, name='locality-index'),
    path('locality/<int:locality_id>', views.locality.show, name='locality-show'),
    path('price/', views.price.index, name='price-index'),
    path('price/<int:price_id>', views.price.show, name='price-show'),
    path('location/', views.location.index, name='location-index'),
    path('location/<int:location_id>', views.location.show, name='location-show'),
]


21.2.	Créer une vue et un template
reservations\catalogue\views\__init__.py
from .artist import *
from .type import *
from .locality import *
from .price import *
from .location import *

Dans le module views , nous importons tout du module location. Créez le fichier location.py suivant :
reservations\catalogue\views\location.py
from django.shortcuts import render
from django.http import Http404

from catalogue.models import Location

def index(request):
    locations = Location.objects.all()
    title = 'Liste des lieux de spectacle'
    
    return render(request, 'location/index.html', {
        'locations':locations,
        'title':title
    })

def show(request, location_id):
    try:
        location = Location.objects.get(id=location_id)
    except Location.DoesNotExist:
        raise Http404('Lieu inexistant');
        
    title = "Fiche d'un lieu de spectacle"
    
    return render(request, 'location/show.html', {
        'location':location,
        'title':title 
    })


21.3.	Créer les templates
Ensuite, nous créons les templates index.html qui devra afficher la liste des lieux de spectacle, et show.html qui devra afficher un lieu. N’oubliez pas de créer le dossier location.
reservations/catalogue/templates/location/index.html
{% extends 'layouts/base.html' %}

{% block title %}Liste des lieux de spectacle{% endblock %}

{% block content %}
    <h1>{{ title }}</h1>
    <ul>
    {% for location in locations %}
        <li>
		<a href="{% url 'catalogue:location-show' location.id %}"> 				{{ location.designation }}
		</a>
        	{% if location.website %}
         	 - <a href="{{ location.website }}">{{ location.website }}</a>
        	{% endif %}
        </li>
    {% endfor %}
    </ul>
{% endblock %}



reservations/catalogue/templates/location/show.html
{% extends 'layouts/base.html' %}

{% block title %}{{ title }}{% endblock %}

{% block content %}
    <h1>{{ location.designation }}</h1>
    
        <address>
            <p>{{ location.address }}</p>
            <p>{{ location.locality.postal_code }} {{ location.locality.locality }}</p>

            {% if location.website %}
            <p><a href="{{ location.website }}" target="_blank">{{ location.website }}</a></p>
            {% else %}
            <p>Pas de site web</p>
            {% endif %}
            
            {% if location.phone %}
            <p><a href="tel:{{ location.phone }}">{{ location.phone }}</a></p>
            {% else %}
            <p>Pas de téléphone</p>
            {% endif %}
        </address>
        
        <h2>Liste des spectacles</h2>
        <ul>
        {% for show in location.shows.all %}
            <li>{{ show.title }}</li>
        {% endfor %}
        </ul>

        <nav><a href="{% url 'catalogue:location-index' %}">Retour à l'index</a></nav>

{% endblock %}


Remarquez que nous exécutons la méthode all pour obtenir un QuerySet itérable pour la boucle for.
•	Lancer le serveur interne
py manage.py runserver
•	Accéder à l’URL http://localhost:8000/catalogue/location 
•	Accéder à l’URL http://localhost:8000/catalogue/location/1
   
22.	Versionner le projet
git status
git add .
git commit -m "View & template location with shows"
23.	Définir une route
Modifiez le fichier urls.py de l’application catalogue de façon à définir les routes show_index et show_show.
catalogue/urls.py
"""reservations.catalogue URL Configuration
"""
from django.urls import path

from . import views

app_name='catalogue'

urlpatterns = [
    path('artist/', views.artist.index, name='artist-index'),
    path('artist/<int:artist_id>', views.artist.show, name='artist-show'),
    path('artist/edit/<int:artist_id>', views.artist.edit, name='artist-edit'),
    path('artist/create', views.artist.create, name='artist-create'),
    path('artist/delete/<int:artist_id>', views.artist.delete, name='artist-delete'),
    path('type/', views.type.index, name='type-index'),
    path('type/<int:type_id>', views.type.show, name='type-show'),
    path('locality/', views.locality.index, name='locality-index'),
    path('locality/<int:locality_id>', views.locality.show, name='locality-show'),
    path('price/', views.price.index, name='price-index'),
    path('price/<int:price_id>', views.price.show, name='price-show'),
    path('location/', views.location.index, name='location-index'),
    path('location/<int:location_id>', views.location.show, name='location-show'),
    path('show/', views.show_.index, name='show-index'),
    path('show/<int:show_id>', views.show_.show, name='show-show'),
]


23.1.	Créer une vue et un template
reservations\catalogue\views\__init__.py
from .artist import *
from .type import *
from .locality import *
from .price import *
from .location import *
from .show_ import *

Attention, le mot show étant réservé, nommons le fichier avec un underscore pour éviter les bugs.
Dans le module views , nous importons tout du module show_. Créez le fichier show_.py suivant :
reservations\catalogue\views\show_.py
from django.shortcuts import render
from django.http import Http404

from catalogue.models import Show

def index(request):
    shows = Show.objects.all()
    title = 'Liste des spectacles'
    
    return render(request, 'show/index.html', {
        'shows':shows,
        'title':title
    })

def show(request, show_id):
    try:
        show = Show.objects.get(id=show_id)
    except Show.DoesNotExist:
        raise Http404('Spectacle inexistant');
        
    title = "Fiche d'un spectacle"
    
    return render(request, 'show/show.html', {
        'show':show,
        'title':title 
    })


23.2.	Créer les templates
Ensuite, nous créons les templates index.html qui devra afficher la liste des spectacles, et show.html qui devra afficher un spectacle et son lieu. N’oubliez pas de créer le dossier show.
reservations/catalogue/templates/show/index.html
{% extends 'layouts/base.html' %}

{% block title %}Liste des spectacles{% endblock %}

{% block content %}
    <h1>{{ title }}</h1>
    <ul>
    {% for show in shows %}
        <li>
		<a href="{% url 'catalogue:show-show' show.id %}"> 				  {{ show.title }}
		</a>
        	{% if not show.bookable %}
            <em>Réservation indisponible</em>
        	{% endif %}
        </li>
    {% endfor %}
    </ul>
{% endblock %}


reservations/catalogue/templates/show/show.html
{% extends 'layouts/base.html' %}

{% load static %}

{% block title %}{{ title }}{% endblock %}

{% block content %}
    <h1>{{ show.title }}</h1>

    {% if show.poster_url %}
    <p><img src="{% static 'catalogue/images/' %}{{ show.poster_url }}" alt="{{ show.title }}" width="200"></p>
    {% else %}
    <canvas width="200" height="100" style="border:1px solid #000000;"></canvas>
    {% endif %}
    
    {% if show.location %}
    <p><strong>Lieu de création:</strong> {{ show.location.designation }}</p>
    {% endif %}
        
    <p><strong>Durée :</strong> {{ show.duration }} minutes</p>
    <p><strong>Année de création :</strong> {{ show.created_in }}</p>
        
    {% if show.bookable %}
    <p><em>Réservable</em></p>
    {% else %}
    <p><em>Non réservable</em></p>
    {% endif %}

    <nav><a href="{% url 'catalogue:show-index' %}">Retour à l'index</a></nav>
{% endblock %}


Remarquez que nous utilisons la directive {% static 'catalogue/images' %} pour générer l’URL du dossier des images. A cela, nous ajoutons {{ show.poster_url }} pour compléter l’URL du fichier. Pour que tout cela fonctionne, il ne faut pas oublier la directive {% load static %}.
Enfin et surtout, vous devez créer les dossiers static/catalogue/images dans l’application catalogue et y mettre vos images.

Vous devez aussi redémarrez le serveur.

•	Lancer le serveur interne
py manage.py runserver
•	Accéder à l’URL http://localhost:8000/catalogue/show
•	Accéder à l’URL http://localhost:8000/catalogue/show/1
   
30.	Versionner le projet
git status
git add .
git commit -m "Vue Show +template +route"
 
Solution pour la  classe Representation
Mapping relationnel, migration et données test
La classe Location est en relation many-to-one avec la classe Representation. En effet, un lieu peut être le lieu de représentation de plusieurs spectacles. Tandis qu’une représentation ne se donne que dans un seul lieu.
2.	Créer le modèle Representation (et sa relation avec le modèle Location)
Dans le module models, nous importons tout des modules representation.
reservations\catalogue\models\__init__.py
from .artist import *
from .user_meta import *
from .type import *
from .locality import *
from .price import *
from .location import *
from .reservation import *
from .show import *
from .representation import *

Créez un fichier de modèle catalogue/models/show.py. Définissez la classe Representation, ainsi que  ses propriétés. Ensuite, précisez le nom de la table au moyen de la métadonnée db_table.
catalogue\models\representation.py
from django.db import models
from .show import *
from .location import *

class Representation(models.Model):
    show = models.ForeignKey(Show, on_delete=models.RESTRICT, null=False, related_name='representations')
    schedule = models.DateTimeField()
    location = models.ForeignKey(Location, on_delete=models.RESTRICT, null=True, related_name='representations')

    def __str__(self):
        return f"{self.show.slug} @ {self.schedule}"
    
    class Meta:
        db_table = "representations"


Notez la contrainte d’intégrité on_delete définie à RESTRICT pour empêcher la suppression des spectacles et des lieux de spectacle qui ont une représentation. Aussi, le show ne peut pas être nul mais le lieu peut l’être car dans ce cas la représentation se donnera dan le lieu de création (show.location). 
•	Créer les migrations
py manage.py makemigrations catalogue
Vérifiez le fichier généré catalogue/migrations/0008_representation_location_unique_slug….py :
catalogue/migrations/0008_representation_location_unique_slug….py 
# Generated by Django 5.1.2 on 2025-01-06 00:50

import django.db.models.deletion
from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ('catalogue', '0007_show'),
    ]

    operations = [
        migrations.CreateModel(
            name='Representation',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('schedule', models.DateTimeField()),
            ],
            options={
                'db_table': 'representations',
            },
        ),
        migrations.AddConstraint(
            model_name='location',
            constraint=models.UniqueConstraint(fields=('slug', 'website'), name='unique_slug_website'),
        ),
        migrations.AddField(
            model_name='representation',
            name='location',
            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.RESTRICT, related_name='representations', to='catalogue.location'),
        ),
        migrations.AddField(
            model_name='representation',
            name='show',
            field=models.ForeignKey(on_delete=django.db.models.deletion.RESTRICT, related_name='representations', to='catalogue.show'),
        ),
    ]


•	Exécuter les migrations
python manage.py migrate
Dans la base de données, la table representations a été créée.
Tester les modèles en ligne de commande
15.	Tester nos modèles de données avec le shell de Django
Créons des représentations de spectacle dans différents lieux (Representation, Show, Location).
https://docs.djangoproject.com/fr/5.1/topics/db/queries/
py manage.py shell

from catalogue.models import Representation, Location, Show
from datetime import datetime, timezone

delvaux = Location.objects.filter(slug="espace-delvaux-la-venerie").first()
dexia = Location.objects.filter(slug="dexia-art-center").first()
samaritaine = Location.objects.filter(slug="la-samaritaine").first()

ayiti = Show.objects.filter(slug='ayiti').first()
cible = Show.objects.filter(slug='cible-mouvante').first()
chanteur = Show.objects.filter(slug='ceci-nest-pas-un-chanteur-belge').first()

rep = Representation(show=ayiti,location=delvaux,
	schedule= datetime(2012,10,12,13,30,tzinfo=timezone.utc))
rep.save()

rep = Representation(show=ayiti,location=dexia,
	schedule=datetime(2012,10,12,20,30,tzinfo=timezone.utc))
rep.save()

rep = Representation(show=cible ,
	schedule=datetime(2012,10,2,20,30,tzinfo=timezone.utc))
rep.save()

rep = Representation(show=chanteur ,
	schedule=datetime(2012,10,16,20,30,tzinfo=timezone.utc))
rep.save()


Representation.objects.all()
 
Nous avons créé trois représentations du spectacle « Ayiti » dans deux lieux différents, une représentation pour « Cible mouvante » et une autre pour « Ceci n’est pas un chanteur belge » sans lieu particulier. Vérifiez dans votre base de données.
Remarquez que pour l’horaire de la représentation nous avons importé les utilitaires datetime et timezone importés de datetime.
A présent, testons les relations entre Representation, Show et Location :
repAyiti = Representation.objects.filter(show=ayiti).first()
repAyiti.location
repAyiti.location.representations.all()
repAyiti.location.shows.all()
Pour tester la relation many-to-one, nous recherchons la première représentation du spectacle « Ayiti ». Notez que nous avions déjà récupéré cet objet au préalable. Ensuite, nous affichons son lieu de représentation. Puis, toutes les représentations qui se donnent dans ce lieu. Enfin, tous les spectacles créés dans ce lieu.
repAyiti.show
repAyiti.show.location
repAyiti.show.location.representations.all()
repAyiti.show.representations.all()

Representation.objects.filter(location=dexia)
Accédons au spectacle de cette représentation. Puis, à son lieu de création. À toutes les représentations qui se donnent dans ce lieu (quelque soit le spectacle). Enfin, à toutes les représentations de ce spectacle.
Nous pouvons aussi utiliser la fonction de recherche filter().
from datetime import date
Representation.objects.filter(schedule__date=date(2012,10,12))
Representation.objects.filter(schedule__year=2012)
Representation.objects.filter(schedule__month=10)
Representation.objects.filter(schedule__day=12)
Representation.objects.filter(schedule__date__range=(
	date(2012,10,1),
	date(2012,10,15)))


from datetime import time
Representation.objects.filter(schedule__time=time(20,30))

Representation.objects.filter(
	schedule__date=date(2012,10,12),
 	schedule__time=time(20,30))

exit()
Enfin, nous effectuons une série de recherche sur le champ schedule de type DateTime.
Si toutes les commandes testées dans Django Shell fonctionnent, le mapping relationnel est correct.
•	Versionner le projet
git status
git add .
git commit -m "Modèle Representation +Relation ManyToOne with Show"
git push
Données de test
Representation hasMany Show
•	Insérer un jeu de données de test dans la table
.1.	Exporter des données initiales pour le modèle (fixtures)
Nous avons déjà créé des instances de représentations lors de nos tests. Avant d’exporter les données, définissons des clés naturelles pour le modèle Show.
•	Définir des références naturelles pour les relations
https://docs.djangoproject.com/fr/5.1/topics/serialization/#natural-keys
Pour ajouter la capacité de clé naturelle à nos modèles, il suffit de leur définir un gestionnaire par défaut avec une méthode get_by_natural_key(). Dans le cas du modèle Show, nous pouvons utiliser le slug, puisqu’il est censé être unique, et le champ created_in.
Modifions le modèle Show :
reservations\catalogue\models\show.py
from django.db import models
from .location import *

class ShowManager(models.Manager):
    def get_by_natural_key(self, slug, created_in):
        return self.get(slug=slug, created_in=created_in)

class Show(models.Model):
    slug = models.CharField(max_length=60, unique=True)
    title = models.CharField(max_length=255)
    description = models.TextField(max_length=255, null=True)
    poster_url = models.CharField(max_length=255, null=True)
    duration = models.PositiveSmallIntegerField(null=True)
    created_in = models.PositiveSmallIntegerField()
    location = models.ForeignKey(Location, on_delete=models.SET_NULL, null=True, related_name='shows')
    bookable = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(null=True)

    objects = ShowManager()

    def __str__(self):
        return self.title

    class Meta:
        db_table = "shows"
        constraints = [
            models.UniqueConstraint(
                fields=["slug", "created_in"],
                name="unique_slug_created_in",
            ),
        ]
    
    def natural_key(self):
        return (self.slug, self.created_in)


.1.	Exporter des données initiales pour le modèle (fixtures)
Nous pouvons ensuite exécuter le dump des données initiales en ajoutant l’option --natural-foreign :
py -Xutf8 manage.py dumpdata catalogue.representation --indent=2 --natural-foreign > catalogue\fixtures\representations.json
reservations\catalogue\fixtures\representations.json
[
{
  "model": "catalogue.representation",
  "pk": 1,
  "fields": {
    "show": [
      "ayiti",
      2010
    ],
    "schedule": "2012-10-12T13:30:00Z",
    "location": [
      "espace-delvaux-la-venerie",
      "https://www.lavenerie.be"
    ]
  }
},
{
  "model": "catalogue.representation",
  "pk": 2,
  "fields": {
    "show": [
      "ayiti",
      2010
    ],
    "schedule": "2012-10-12T20:30:00Z",
    "location": [
      "dexia-art-center",
      null
    ]
  }
},
{
  "model": "catalogue.representation",
  "pk": 3,
  "fields": {
    "show": [
      "cible-mouvante",
      2012
    ],
    "schedule": "2012-10-02T20:30:00Z",
    "location": null
  }
},
{
  "model": "catalogue.representation",
  "pk": 4,
  "fields": {
    "show": [
      "ceci-nest-pas-un-chanteur-belge",
      2014
    ],
    "schedule": "2012-10-16T20:30:00Z",
    "location": null
  }
}
]


Grâce aux clés naturelles, remarquez qu’au lieu d’avoir l’id de clé étrangère pour le show et la location, nous avons les tuples slug et created_in d’une part, ainsi que slug et website d’autre part.
    "show": [
      "ayiti",
      2010
    ],

    "location": [
      "espace-delvaux-la-venerie",
      "https://www.lavenerie.be"
    ],

Enfin, nous pouvons inversement exécuter le chargement des données initiales vers la base de données :
2.1.	Exécutez le chargement des fixtures :
py manage.py loaddata representations.json
Vous pouvez vérifier dans la table representations la bonne insertion des mêmes données.
 
•	Créer les migrations
Si tout s’est bien passé, il ne faut pas oublier de créer une migration puisque nous avons modifié notre modèle Show.
python manage.py makemigrations catalogue
Vérifiez le fichier généré catalogue/migrations/0009_show_unique_slug_created_at.py :
catalogue/migrations/0009_show_unique_slug_created_at.py 
# Generated by Django 5.1.2 on 2025-01-06 10:30

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ('catalogue', '0008_representation_location_unique_slug_website_and_more'),
    ]

    operations = [
        migrations.AddConstraint(
            model_name='show',
            constraint=models.UniqueConstraint(fields=('slug', 'created_at'), name='unique_slug_created_at'),
        ),
    ]


24.	Exécuter les migrations
python manage.py migrate
Dans la base de données, la table shows a été modifiée.
25.	Versionner le projet
git status
git add .
git commit -m "Données initiales Representation avec clés naturelles Show & Location"
git push
Vues et templates
26.	Définir une route
Modifiez le fichier urls.py de l’application catalogue de façon à définir les routes representation-index et representation-show.
catalogue/urls.py
"""reservations.catalogue URL Configuration
"""
from django.urls import path

from . import views

app_name='catalogue'

urlpatterns = [
    path('artist/', views.artist.index, name='artist-index'),
    path('artist/<int:artist_id>', views.artist.show, name='artist-show'),
    path('artist/edit/<int:artist_id>', views.artist.edit, name='artist-edit'),
    path('artist/create', views.artist.create, name='artist-create'),
    path('artist/delete/<int:artist_id>', views.artist.delete, name='artist-delete'),
    path('type/', views.type.index, name='type-index'),
    path('type/<int:type_id>', views.type.show, name='type-show'),
    path('locality/', views.locality.index, name='locality-index'),
    path('locality/<int:locality_id>', views.locality.show, name='locality-show'),
    path('price/', views.price.index, name='price-index'),
    path('price/<int:price_id>', views.price.show, name='price-show'),
    path('location/', views.location.index, name='location-index'),
    path('location/<int:location_id>', views.location.show, name='location-show'),
    path('representation/', views.representation.index, name='representation-index'),
    path('representation/<int:representation_id>', views.representation.show, name='representation-show'),
]


26.1.	Créer une vue et un template
reservations\catalogue\views\__init__.py
from .artist import *
from .type import *
from .locality import *
from .price import *
from .location import *
from .show_ import *
from .representation import *

Dans le module views , nous importons tout du module location. Créez le fichier representation.py suivant :
reservations\catalogue\views\representation.py
from django.shortcuts import render
from django.http import Http404

from catalogue.models import Representation

def index(request):
    representations = Representation.objects.all()
    title = 'Liste des représentations'
    
    return render(request, 'representation/index.html', {
        'representations':representations,
        'title':title
    })

def show(request, representation_id):
    try:
        representation = Representation.objects.get(id=representation_id)
    except Representation.DoesNotExist:
        raise Http404('Représentation inexistante');
        
    title = "Fiche d'une représentation"
    rep_date = representation.schedule.strftime('%Y-%m-%d')
    rep_time = representation.schedule.strftime('%H:%M')
    
    return render(request, 'representation/show.html', {
        'representation':representation,
        'title':title,
        'rep_date':rep_date,
        'rep_time':rep_time,
    })



26.2.	Créer les templates
Ensuite, nous créons les templates index.html qui devra afficher la liste des représentations d’un spectacle, et show.html qui devra afficher le détail d’une représentation. N’oubliez pas de créer le dossier representation.
reservations/catalogue/templates/representation/index.html
{% extends 'layouts/base.html' %}

{% block title %}Liste des représentations{% endblock %}

{% block content %}
    <h1>{{ title }}</h1>
    <ul>
    {% for representation in representations %}
        <li><datetime>{{ representation.schedule|date:'Y-m-d' }}</datetime>
            - {{ representation.show.title }}
        
            {% if representation.location %}
             - <span>{{ representation.location.designation }}</span>
            {% elif representation.show.location %}
             - <span>{{ representation.show.location.designation }}</span>
            {% else %}
             - <em>Pas de lieu</em>
            {% endif %}

            <a href="{% url 'catalogue:representation-show' representation.id %}">&#128065;</a>
        </li>
    {% endfor %}
    </ul>
{% endblock %}


reservations/catalogue/templates/representation/show.html
{% extends 'layouts/base.html' %}

{% block title %}{{ title }}{% endblock %}

{% block content %}
<article>
    <h1>Représentation du {{ rep_date }} à {{ rep_time }}</h1>
    <p><strong>Spectacle:</strong> {{ representation.show.title }}</p>

    <p><strong>Lieu:</strong>
    {% if representation.location %}
    {{ representation.location.designation }}
    {% elif representation.show.location %}
    {{ representation.show.location.designation }}
    {% else %}
    <em>à déterminer</em>
    {% endif %}
    </p>
</article>

<nav><a href="{% url 'catalogue:representation-index' %}">Retour à l'index</a></nav>
{% endblock %}


S’il y a un lieu de représentation, nous l’affichons. Sinon nous affichons le lieu de création. Nous formatons l’horaire avec le filter date:Y-m-d dans le template index.html, ou nous le faisons dans la méthode show() de la vue avec la fonction strftime().
•	Lancer le serveur interne
py manage.py runserver
•	Accéder à l’URL http://localhost:8000/catalogue/representation 
•	Accéder à l’URL http://localhost:8000/catalogue/representation/1
  
   
27.	Versionner le projet
git status
git add .
git commit -m "View & template representation with shows & location"
git push
Solution pour la  classe Review
Mapping relationnel, migration et données test
La classe Review est en relation OneToMany inverse avec la classe User, mais aussi en relation OneToMany inverse avec la classe Show.

À vous d’écrire la suite !

Liste des commandes
•	Créer le modèle Review (en sa relation avec les modèles User et Representation)
reservations\catalogue\models\__init__.py
from .artist import *
from .user_meta import *
from .type import *
from .locality import *
from .price import *
from .location import *
from .reservation import *
from .show import *
from .representation import *
from .review import *

•	Créez un fichier de modèle catalogue/models/review.py.
catalogue\models\review.py
from django.db import models
from .show import *
from django.contrib.auth.models import User

class Review(models.Model):
    user = models.ForeignKey(User, on_delete=models.RESTRICT,
        null=False, related_name='user')
    show = models.ForeignKey(Show, on_delete=models.RESTRICT, 
		null=False, related_name='show')
    review = models.TextField()
    stars = models.PositiveSmallIntegerField()
    validated = models.BooleanField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(null=True)

    def __str__(self):
        return f"{self.user.username} - {self.show.title} : {self.stars}"
    
    class Meta:
        db_table = "reviews"


•	Créer les migrations
py manage.py makemigrations catalogue
•	Exécuter les migrations
py manage.py migrate
•	Tester nos modèles de données avec le shell de Django
py manage.py shell
from django.contrib.auth.models import User
from catalogue.models import Review, Show

ayiti = Show.objects.filter(slug='ayiti').first()
cible = Show.objects.filter(slug='cible-mouvante').first()

bob = User.objects.filter(username='bob').first()
anna = User.objects.filter(username='anna').first()


rev = Review(show=ayiti,user=bob,review='Excellent.',stars=5,validated=True)
rev.save()

rev = Review(show=cible,user=bob,review='Pas mal.',stars=3,validated=False)
rev.save()

rev = Review(show=ayiti,user=anna,review='Magnifique!',stars=5,validated=True)
rev.save()


Review.objects.all()

rev = Review.objects.filter(id=1).first()
rev.user
rev.show

rev.user.reviews.all()
rev.show.reviews.all()

bob.reviews.all()
ayiti.reviews.all()

exit()
•	Exporter des données initiales pour le modèle
py -Xutf8 manage.py dumpdata catalogue.review --indent=2 --natural-foreign > catalogue\fixtures\reviews.json
•	Exécutez le chargement des fixtures :
py manage.py loaddata reviews.json

 
•	Versionner le projet
git status
git add .
git commit -m "Modèle Review +Relation ManyToOne with User & Show"
git push

 
Chapitre 7 – Modéliser les relations complexes
Il est temps d’aborder les relations ManyToMany entre tables. C’est le cas respectivement pour la relation artists  types, reservations  representations, users  roles, prices  shows, mais aussi artist_type  shows.
https://docs.djangoproject.com/fr/5.1/topics/db/examples/many_to_many/ 
Relation ManyToMany
Dans ce cas-ci, il y aura une table intermédiaire qui regroupe les clés primaires des deux tables en relation. Toutefois, nous ne créons ni modèle ni vue pour cette table. Commençons par définir la relation ManyToMany dans les modèles Artist et Type.
En Django, pour définir une relation many-to-many, utilisez un champ ManyToManyField dans un des deux modèles au choix.
•	Modifiez le modèle Artist de façon à ajouter la relation ManyToMany.
 
catalogue\models\artist.py
from django.db import models
from .type import *

class Artist(models.Model):
    firstname = models.CharField(max_length=60)
    lastname = models.CharField(max_length=60)
    types = models.ManyToManyField(Type , related_name='artists', db_table='artist_type')

    def __str__(self):
        return self.firstname +" "+ self.lastname
    
    class Meta:
        db_table = "artists"


Ajoutons l’attribut types de type ManyToManyField en relation avec le modèle Type. Grâce au paramètre related_name, nous pouvons spécifier le nom de la propriété inverse dans le modèle Type. Notez que nous spécifions aussi le nom que devra porter la table intermédiaire : artist_type.
•	Créer les migrations
Puisque nous avons modifié le modèle, nous devons créer une migration et l’exécuter.
py manage.py makemigrations catalogue
Vérifiez le fichier généré catalogue/migrations/0011_artist_types.py :
catalogue/migrations/0011_artist_types.py
# Generated by Django 4.2 on 2025-01-07 19:08

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ('catalogue', '0010_review'),
    ]

    operations = [
        migrations.AddField(
            model_name='artist',
            name='types',
            field=models.ManyToManyField(db_table='artist_type', related_name='artists', to='catalogue.type'),
        ),
    ]


•	Exécuter les migrations
python manage.py migrate
Dans la base de données, la table artist_type a été créée.
Tester les modèles en ligne de commande
16.	Tester nos modèles de données avec le shell de Django
Pour tester l’accès aux données et les relations, utilisons les méthodes de l’ORM dans le shell de Django.
https://docs.djangoproject.com/fr/5.1/topics/db/queries/
py manage.py shell

from catalogue.models import Artist, Type

marcelin = Artist.objects.filter(lastname='Marcelin').first() 
laurent = Artist.objects.filter(lastname='Laurent').first() 

auteur = Type.objects.filter(type='auteur').first() 
sceno = Type.objects.filter(type='scénographe').first() 
comedien = Type.objects.filter(type='comédien').first() 


marcelin.types.add(auteur)
laurent.types.add(auteur)

marcelin.types.add(sceno)
sceno.artists.add(laurent)

marcelin.types.all()
auteur.artists.all()

exit()
Nous commençons par récupérer deux artistes et trois types. Ensuite, nous ajoutons le type « auteur » à nos deux artistes, grâce à la méthode add().
Dans le deuxième exemple, nous voyons que nous pouvons ajouter le type « scénographe » aux deux artistes soit en partant de l’artiste et son attribut types, soit en partant du type et son attribut artists.
Enfin, nous affichons tous les types de l’artiste « Marcelin », puis tous les artistes de type « auteur ».
Si toutes les commandes testées dans Django Shell fonctionnent, le mapping relationnel est correct.
•	Versionner le projet
git status
git add .
git commit -m "Relation ManyToMany between Artist & Type"
git push
Données de test
•	Insérer un jeu de données de test dans la table
Nous avons déjà créé des instances de représentations lors de nos tests. Avant d’exporter les données, définissons des clés naturelles pour le modèle Show.
•	Définir des références naturelles pour les relations
https://docs.djangoproject.com/fr/5.1/topics/serialization/#natural-keys
Pour ajouter la capacité de clé naturelle à nos modèles, il suffit de leur définir un gestionnaire par défaut avec une méthode get_by_natural_key(). Dans le cas du modèle Artist, utilisons le firstname et le lastname en combinaison.
Modifions le modèle Artist :
reservations\catalogue\models\artist.py
from django.db import models
from .type import *

class ArtistManager(models.Manager):
    def get_by_natural_key(self, firstname, lastname):
        return self.get(firstname=firstname, lastname=lastname)

class Artist(models.Model):
    firstname = models.CharField(max_length=60)
    lastname = models.CharField(max_length=60)
    types = models.ManyToManyField(Type, related_name='artists', db_table='artist_type')

    objects = ArtistManager()

    def __str__(self):
        return self.firstname +" "+ self.lastname
    
    class Meta:
        db_table = "artists"
        constraints = [
            models.UniqueConstraint(
                fields=["firstname", "lastname"],
                name="unique_firstname_lastname",
            ),
        ]

    def natural_key(self):
        return (self.firstname, self.lastname)

Modifions le modèle Type :
reservations\catalogue\models\type.py
from django.db import models

class TypeManager(models.Manager):
    def get_by_natural_key(self, type,):
        return self.get(type=type,)

class Type(models.Model):
    type = models.CharField(max_length=60)
    
    objects = TypeManager()
    
    def __str__(self):
        return self.type

    class Meta:
        db_table = "types"

    def natural_key(self):
        return (self.type,)

Dans le cas du modèle Type, nous n’avons qu’un seul champ à disposition, le champ type. Cela tombe bien car il est unique. Toutefois, il nous faut obligatoirement un tuple. C’est pourquoi, nous laissons une virgule flottante ici et là (lignes en gras). Si vous exécutez le dump sans ce détail (voir plus loin, commande dumpdata), vous obtiendrez certes des données exportées mais vous ne pourrez pas les importer inversement avec la commande loaddata.
Extrait de reservations\catalogue\fixtures\artist_type.json – Version incorrecte :
{
  "model": "catalogue.artist_types",
  "pk": 1,
  "fields": {
    "artist": [
      "Daniel",
      "Marcelin"
    ],
    "type": "auteur"	//Pas un tuple !
  }
},

Extrait de reservations\catalogue\fixtures\artist_type.json – Version correcte :
{
  "model": "catalogue.artist_types",
  "pk": 1,
  "fields": {
    "artist": [
      "Daniel",
      "Marcelin"
    ],
    "type": [
      "auteur"
    ]
  }
},

.1.	Exporter des données initiales pour le modèle (fixtures)
Nous pouvons ensuite exécuter le dump des données initiales en ajoutant l’option --natural-foreign :
py -Xutf8 manage.py dumpdata catalogue.artist_types --indent=2 --natural-foreign > catalogue\fixtures\artist_type.json
Remarquez la notation pour spécifier le modèle inexistant : catalogue.artist_types. Nous faisons références à l’attribut types du modèle Artist. Nous devons renommer le nom du modèle pour enlever le pluriel. Vous pouvez aussi ajouter les données supplémentaires de l’exemple ci-dessous :
reservations\catalogue\fixtures\artist_type.json
[
{
  "model": "catalogue.artist_type",
  "pk": 1,
  "fields": {
    "artist": [
      "Daniel",
      "Marcelin"
    ],
    "type": [
      "auteur"
    ]
  }
},
{
  "model": "catalogue.artist_type",
  "pk": 2,
  "fields": {
    "artist": [
      "Philippe",
      "Laurent"
    ],
    "type": [
      "auteur"
    ]
  }
},
{
  "model": "catalogue.artist_type",
  "pk": 3,
  "fields": {
    "artist": [
      "Daniel",
      "Marcelin"
    ],
    "type": [
      "scénographe"
    ]
  }
},
{
  "model": "catalogue.artist_type",
  "pk": 5,
  "fields": {
    "artist": [
      "Daniel",
      "Marcelin"
    ],
    "type": [
      "comédien"
    ]
  }
},
{
  "model": "catalogue.artist_type",
  "pk": 4,
  "fields": {
    "artist": [
      "Philippe",
      "Laurent"
    ],
    "type": [
      "scénographe"
    ]
  }
},
{
  "model": "catalogue.artist_type",
  "pk": 6,
  "fields": {
    "artist": [
      "Marius",
      "Von Mayenburg"
    ],
    "type": [
      "auteur"
    ]
  }
},
{
  "model": "catalogue.artist_type",
  "pk": 7,
  "fields": {
    "artist": [
      "Olivier",
      "Boudon"
    ],
    "type": [
      "scénographe"
    ]
  }
},
{
  "model": "catalogue.artist_type",
  "pk": 8,
  "fields": {
    "artist": [
      "Anne Marie",
      "Loop"
    ],
    "type": [
      "comédien"
    ]
  }
},
{
  "model": "catalogue.artist_type",
  "pk": 9,
  "fields": {
    "artist": [
      "Pietro",
      "Varasso"
    ],
    "type": [
      "comédien"
    ]
  }
},
{
  "model": "catalogue.artist_type",
  "pk": 10,
  "fields": {
    "artist": [
      "Laurent",
      "Caron"
    ],
    "type": [
      "comédien"
    ]
  }
},
{
  "model": "catalogue.artist_type",
  "pk": 11,
  "fields": {
    "artist": [
      "Élena",
      "Perez"
    ],
    "type": [
      "comédien"
    ]
  }
},
{
  "model": "catalogue.artist_type",
  "pk": 12,
  "fields": {
    "artist": [
      "Guillaume",
      "Alexandre"
    ],
    "type": [
      "comédien"
    ]
  }
},
{
  "model": "catalogue.artist_type",
  "pk": 13,
  "fields": {
    "artist": [
      "Claude",
      "Semal"
    ],
    "type": [
      "auteur"
    ]
  }
},
{
  "model": "catalogue.artist_type",
  "pk": 14,
  "fields": {
    "artist": [
      "Laurence",
      "Warin"
    ],
    "type": [
      "scénographe"
    ]
  }
},
{
  "model": "catalogue.artist_type",
  "pk": 15,
  "fields": {
    "artist": [
      "Claude",
      "Semal"
    ],
    "type": [
      "comédien"
    ]
  }
},
{
  "model": "catalogue.artist_type",
  "pk": 16,
  "fields": {
    "artist": [
      "Pierre",
      "Wayburn"
    ],
    "type": [
      "auteur"
    ]
  }
},
{
  "model": "catalogue.artist_type",
  "pk": 17,
  "fields": {
    "artist": [
      "Gwendoline",
      "Gauthier"
    ],
    "type": [
      "auteur"
    ]
  }
},
{
  "model": "catalogue.artist_type",
  "pk": 18,
  "fields": {
    "artist": [
      "Pierre",
      "Wayburn"
    ],
    "type": [
      "comédien"
    ]
  }
},
{
  "model": "catalogue.artist_type",
  "pk": 19,
  "fields": {
    "artist": [
      "Gwendoline",
      "Gauthier"
    ],
    "type": [
      "comédien"
    ]
  }
}
]


Enfin, nous pouvons inversement exécuter le chargement des données initiales.
0.1.	Exécutez le chargement des fixtures :
py manage.py loaddata artist_type.json
Vous pouvez vérifier les données dans la table artist_type.
1.	Versionner le projet
git status
git add .
git commit -m "Données initiales ArtistType"
git push
Templates
•	Modifier les templates show.html
Dans le dossier artist, ajoutons l’affichage des types de l’artiste dans le template show.html.
reservations/catalogue/templates/artist/show.html
{% extends 'layouts/base.html' %}

{% block title %}Fiche d'un artiste{% endblock %}

{% block content %}
    <h2>{{ artist.firstname }} {{ artist.lastname }}</h2>

    <h2>Liste des types</h2>
    <ul>
    {% for type in artist.types.all %}
        <li>{{ type.type }}</li>
    {% endfor %}
    </ul>

    <div><a href="{% url 'catalogue:artist-edit' artist.id %}">Modifier</a></div>
    
    <form method="post" action="{% url 'catalogue:artist-delete' artist.id %}" 
        onsubmit="return confirm('Êtes-vous sûr de vouloir supprimer ?')">
        {% csrf_token %}
        <input type="hidden" name="_method" value="DELETE">
        <button>Supprimer</button>
    </form>
    
    <nav><a href="{% url 'catalogue:artist-index' %}">Retour à l'index</a></nav>
{% endblock %}

Dans le dossier type, ajoutons l’affichage des artistes qui exercent ce type de fonction dans le template show.html.
reservations/catalogue/templates/type/show.html
{% extends 'layouts/base.html' %}

{% block title %}{{ title }}{% endblock %}

{% block content %}
    <h1>{{ type.type|title }}</h1>

    <h2>Liste des artistes</h2>
    <ul>
    {% for artist in type.artists.all %}
        <li>{{ artist.firstname }} {{ artist.lastname }}</li>
    {% endfor %}
    </ul>
{% endblock %}


•	Lancer le serveur interne
py manage.py runserver
•	Accéder à l’URL http://localhost:8000/catalogue/artist/1
•	Accéder à l’URL http://localhost:8000/catalogue/type/1
 
•	Versionner le projet
git status
git add .
git commit -m "Update templates Artist & Type"
git push
Relation ManyToMany avec table pivot
Dans ce cas-ci, nous avons finalement besoin de créer le modèle ArtistType pour la table pivot artist_type! Ceci afin de pouvoir réaliser une relation ManyToMany entre les modèles ArtistType et Show.
 
Pour nos migrations, cela va poser un problème car toute nouvelle migration risque de demander re créer la table artist_type. Or cette table a déjà été créée via la relation ManyToMany entre Artist et Type.
Une première solution consiste à marquer le modèle ArtistType avec l’attribut managed = False. Cela dit à Django de ne pas créer de table pour ce modèle.
class Artist(models.Model):
    firstname = models.CharField(max_length=60)
    lastname = models.CharField(max_length=60)

    def __str__(self):
        return self.firstname +" "+ self.lastname
    
    class Meta:
        db_table = "artists"
        managed = False

Toutefois, cette solution n’a pas été retenue car elle entraîne d’autres problèmes plus difficiles à résoudre.
Une meilleure approche consiste à supprimer la relation ManyToMany pour la remplacer par deux relations ManyToOne. Il y a toutefois un problème à cette solution car nous perdons les attributs Artists.types et inversement Type.artists. Il suffira dès lors de passer par le modèle intermédiaire Artist.a_artistTypes et Type.t_artistTypes. C’est pourquoi, il faudra aussi corriger nos templates.
Étape 1 – Suppression de la relation ManyToMany
•	Modifiez le modèle Artist de façon à supprimer la relation ManyToMany.
catalogue\models\artist.py
from django.db import models
from .type import *

class Artist(models.Model):
    firstname = models.CharField(max_length=60)
    lastname = models.CharField(max_length=60)
    #types = models.ManyToManyField(Type , related_name='artists', db_table='artist_type')

    def __str__(self):
        return self.firstname +" "+ self.lastname
    
    class Meta:
        db_table = "artists"


En supprimant l’attribut types de type ManyToManyField, la table intermédiaire artist_type sera supprimée lors de la prochaine migration. Veillez à exporter les données si nécessaire. Dans notre cas, nous avons toujours les données initiales artist_types.json dans le dossier fixtures.
•	Créer les migrations
Puisque nous avons modifié le modèle, nous devons créer une migration et l’exécuter.
py manage.py makemigrations catalogue
Vérifiez le fichier généré catalogue/migrations/0012_remove_artist_types_....py :
catalogue/migrations/0012_remove_artist_types_artist_unique_firstname_lastname.py
# Generated by Django 5.1.2 on 2025-01-11 02:59

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ('catalogue', '0011_artist_types'),
    ]

    operations = [
        migrations.RemoveField(
            model_name='artist',
            name='types',
        ),
        migrations.AddConstraint(
            model_name='artist',
            constraint=models.UniqueConstraint(fields=('firstname', 'lastname'), name='unique_firstname_lastname'),
        ),
    ]


•	Exécuter les migrations
python manage.py migrate
Dans la base de données, assurez-vous que la table artist_type a été supprimée.
Étape 2 – Création des modèles intermédiaires
•	Créez le modèle ArtistType de façon à définir deux relations ManyToOne.
catalogue\models\artist_type.py
from django.db import models
from .artist import *
from .type import *

class ArtistType(models.Model):
    artist = models.ForeignKey(Artist, on_delete=models.RESTRICT, 
		null=False, related_name='a_artistTypes')
    type = models.ForeignKey(Type, on_delete=models.RESTRICT, 
		null=False, related_name='t_artistTypes')

    def __str__(self):
        return f"{self.artist.firstname} {self.artist.lastname} ({self.type.type})"
    
    class Meta:
        db_table = "artist_type"
     

Nous définissons l’attribut artist qui est une relation ManyToOne vers le modèle Artist. De même, l’attribut type, une relation ManyToOne vers le modèle Type.

•	Dans le module models, nous importons tout du module artist_type.
reservations\catalogue\models\__init__.py
from .artist import *
from .user_meta import *
from .type import *
from .locality import *
from .price import *
from .location import *
from .reservation import *
from .show import *
from .representation import *
from .review import *
from .artist_type import *


•	Créer les migrations
Puisque nous avons défini un nouveau modèle, nous devons créer une migration et l’exécuter.
py manage.py makemigrations catalogue
Vérifiez le fichier généré catalogue/migrations/0013_artisttype.py :
catalogue/migrations/0013_artisttype.py
# Generated by Django 5.1.2 on 2025-01-11 03:01

import django.db.models.deletion
from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ('catalogue', '0012_remove_artist_types_artist_unique_firstname_lastname'),
    ]

    operations = [
        migrations.CreateModel(
            name='ArtistType',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('artist', models.ForeignKey(on_delete=django.db.models.deletion.RESTRICT, related_name='a_artistTypes', to='catalogue.artist')),
                ('type', models.ForeignKey(on_delete=django.db.models.deletion.RESTRICT, related_name='t_artistTypes', to='catalogue.type')),
            ],
            options={
                'db_table': 'artist_type',
            },
        ),
    ]


•	Exécuter les migrations
python manage.py migrate
Dans la base de données, assurez-vous que la table artist_type a bien été créée.
•	Créez le modèle ArtistTypeShow de façon à définir deux relations ManyToOne.
catalogue\models\artist_type_show.py
from django.db import models
from .show import *
from .artist_type import *

class ArtistTypeShow(models.Model):
    show = models.ForeignKey(Show, on_delete=models.CASCADE, 
		null=False, related_name='artistTypeShows')
    artist_type = models.ForeignKey(ArtistType, on_delete=models.CASCADE, 
		null=False, related_name='artistTypeShows')

    class Meta:
        unique_together = ("show", "artist_type")  # Optional constraint
        db_table = "artist_type_show"


Nous définissons l’attribut show qui est une relation ManyToOne vers le modèle Show. De même, l’attribut artist_type, une relation ManyToOne vers le modèle ArtistType.
Lorsque nous ferons une migration, une commande de création de la table artist_type_show sera programmée.

•	Dans le module models, nous importons tout du module artist_type_show.
reservations\catalogue\models\__init__.py
from .artist import *
from .user_meta import *
from .type import *
from .locality import *
from .price import *
from .location import *
from .reservation import *
from .show import *
from .representation import *
from .review import *
from .artist_type import *
from .artist_type_show import *


•	Modifiez le modèle Show de façon à définir une relation ManyToMany.
catalogue\models\show.py
from django.db import models
from .location import *

class ShowManager(models.Manager):
    def get_by_natural_key(self, slug, created_in):
        return self.get(slug=slug, created_in=created_in)

class Show(models.Model):
    slug = models.CharField(max_length=60, unique=True)
    title = models.CharField(max_length=255)
    description = models.TextField(max_length=255, null=True)
    poster_url = models.CharField(max_length=255, null=True)
    duration = models.PositiveSmallIntegerField(null=True)
    created_in = models.PositiveSmallIntegerField()
    location = models.ForeignKey(Location, on_delete=models.SET_NULL, null=True, related_name='shows')
    bookable = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(null=True)

    artist_types = models.ManyToManyField(
        "ArtistType",
        through="ArtistTypeShow",
        related_name="shows",
    )

    objects = ShowManager()

    def __str__(self):
        return self.title

    class Meta:
        db_table = "shows"
        constraints = [
            models.UniqueConstraint(
                fields=["slug", "created_in"],
                name="unique_slug_created_in",
            ),
        ]
    
    def natural_key(self):
        return (self.slug, self.created_in)


Nous pouvons enfin définir l’attribut artist_types qui est une relation ManyToMany vers le modèle ArtistType. Toutefois, pour que Django ne programme pas une deuxième fois la création de la table artist_type_show, nous indiquons que la relation sera résolue en passant par le modèle ArtisTypeShow, ceci grâce au paramètre through.

•	Créer les migrations
Après ces modifications aux modèles, nous devons créer une migration et l’exécuter.
py manage.py makemigrations catalogue
Vérifiez le fichier généré catalogue/migrations/0014_artisttypeshow_show_artist_types.py :
catalogue/migrations/0014_artisttypeshow_show_artist_types.py
# Generated by Django 5.1.2 on 2025-01-11 03:08

import django.db.models.deletion
from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ('catalogue', '0013_artisttype'),
    ]

    operations = [
        migrations.CreateModel(
            name='ArtistTypeShow',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('artist_type', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='artistTypeShows', to='catalogue.artisttype')),
                ('show', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='artistTypeShows', to='catalogue.show')),
            ],
            options={
                'unique_together': {('show', 'artist_type')},
            },
        ),
        migrations.AddField(
            model_name='show',
            name='artist_types',
            field=models.ManyToManyField(related_name='shows', through='catalogue.ArtistTypeShow', to='catalogue.artisttype'),
        ),
    ]


•	Exécuter les migrations
python manage.py migrate
Dans la base de données, assurez-vous que la table artist_type_show a bien été créée.
Tester les modèles en ligne de commande
17.	Exécutez le chargement des fixtures
Puisque nous avons supprimé puis recréé la table artist_type, cette table est à présent vide. C’est pourquoi, il faut exécuter le chargement de ces données.
py manage.py loaddata artist_type.json
Si nécessaire, rechargez les autres données de test dans les tables.
18.	Tester nos modèles de données avec le shell de Django
Pour tester l’accès aux données et les relations, utilisons le shell de Django.
https://docs.djangoproject.com/fr/5.1/topics/db/queries/
py manage.py shell

from catalogue.models import Artist, Type, ArtistType, Show

marcelin = Artist.objects.filter(lastname='Marcelin').first() 
laurent = Artist.objects.filter(lastname='Laurent').first() 

auteur = Type.objects.filter(type='auteur').first() 
sceno = Type.objects.filter(type='scénographe').first() 
comedien = Type.objects.filter(type='comédien').first()

ayiti = Show.objects.filter(slug='ayiti').first() 


marcelin_auteur = ArtistType.objects.filter(artist=marcelin,type=auteur).first() 
marcelin_comedien = ArtistType.objects.filter(artist=marcelin,type=comedien).first() 
laurent_sceno = ArtistType.objects.filter(artist=laurent,type=sceno).first() 


marcelin_auteur.shows.add(ayiti)
ayiti.artist_types.add(laurent_sceno)
ayiti.artist_types.add(marcelin_comedien)

marcelin_auteur.shows.all()
marcelin_comedien.shows.all()
ayiti.artist_types.all()
Nous commençons par récupérer deux artistes, trois types et un spectacle. Marcelin est un auteur et un comédien, tandis que Laurent est scénographe. Nous récupérons ces relations. Ensuite, nous ajoutons le spectacle « ayiti » à Marcelin en tant qu’auteur, grâce à la méthode add(). Inversement, nous ajoutons Laurent en tant scénographe et Marcelin en tant que comédien au spectacle « ayiti ».
Enfin, nous affichons tous les spectacles de l’artiste Marcelin. D’abord, en tant qu’auteur, puis en tant que comédien. Enfin, nous affichons tous les collaborateurs du spectacle « ayiti ».
>>> marcelin.types
AttributeError: 'Artist' object has no attribute 'types'

>>> marcelin.a_artistTypes.all()
>>> marcelin.a_artistTypes.all().values_list('type__type',flat=True)


>>> auteur.t_artistTypes.all()
>>> auteur.t_artistTypes.all().values_list('artist__firstname','artist__lastname')

exit()
Nous testons la relation many-to-many entre Artist et Type. Nous ne pouvons plus récupérer directement tous les types de l’artiste « Marcelin » puisque l’attribut types a été retiré. Nous passons alors par l’attribut a_artistTypes.
Si toutes les commandes testées dans Django Shell fonctionnent, le mapping relationnel est correct.
•	Versionner le projet
git status
git add .
git commit -m "Relation ManyToMany between ArtistType & Show"
git push
Corriger les templates
•	Lancer le serveur interne
py manage.py runserver
•	Accéder à l’URL http://localhost:8000/catalogue/artist/1
•	Accéder à l’URL http://localhost:8000/catalogue/type/1
 Constatez que ni les types de l’artiste ni les artistes dont le type est affiché n’apparaissent.
•	Modifier les templates show.html
Si vous tentez d’accéder aux pages 
Dans le dossier artist, corrigeons l’affichage des types de l’artiste dans le template show.html.
reservations/catalogue/templates/artist/show.html
{% extends 'layouts/base.html' %}

{% block title %}Fiche d'un artiste{% endblock %}

{% block content %}
    <h2>{{ artist.firstname }} {{ artist.lastname }}</h2>

    <h2>Liste des types</h2>
    <ul>
    {% for at in artist.a_artitTypes.all %}
        <li>{{ at.type.type }}</li>
    {% endfor %}
    </ul>

    <div><a href="{% url 'catalogue:artist-edit' artist.id %}">Modifier</a></div>
    
    <form method="post" action="{% url 'catalogue:artist-delete' artist.id %}" 
        onsubmit="return confirm('Êtes-vous sûr de vouloir supprimer ?')">
        {% csrf_token %}
        <input type="hidden" name="_method" value="DELETE">
        <button>Supprimer</button>
    </form>
    
    <nav><a href="{% url 'catalogue:artist-index' %}">Retour à l'index</a></nav>
{% endblock %}

Dans le dossier type, ajoutons l’affichage des artistes qui exercent ce type de fonction dans le template show.html.
reservations/catalogue/templates/type/show.html
{% extends 'layouts/base.html' %}

{% block title %}{{ title }}{% endblock %}

{% block content %}
    <h1>{{ type.type|title }}</h1>

    <h2>Liste des artistes</h2>
    <ul>
    {% for at in type.t_artistTypes.all %}
        <li>{{ at.artist.firstname }} {{ at.artist.lastname }}</li>
    {% endfor %}
    </ul>
{% endblock %}


•	Lancer le serveur interne
py manage.py runserver
•	Accéder à l’URL http://localhost:8000/catalogue/artist/1
•	Accéder à l’URL http://localhost:8000/catalogue/type/1
 Les types de l’artiste ainsi que les artistes du type associé s’affichent à nouveau.
•	Versionner le projet
git status
git add .
git commit -m "Refactoring templates Artist & Type"
git push

A vous de jouer !
•	Répétez ces opérations pour les relations entre les modèles Show et Price, Reservation et Representation.
Contentez-vous de modéliser les tables et de définir les relations entre elles. Testez avec Django shell et ne définissez pas encore les vues et les templates.

Commencez par définir les relations entre les modèles Show et Price.
Un spectacle peut avoir plusieurs tarifs. Un tarif peut être utilisé par plusieurs spectacles. Il s’agit donc d’une relation ManyToMany.
.1.	Ajouter les relations ManyToMany entre Show et Price.
.2.	Créer une migration en définissant les champs, les clés étrangères et les contraintes d’intégrité référentielle
.3.	Exécuter la migration
.4.	Tester les relations en ligne de commande avec Django shell
.5.	Générer la classe de données de test (fixtures)
.6.	Définir les données test sans oublier les clés naturelles pour référencer les classes secondaires
.7.	Charger les données test dans la table price_show
•	Versionner le projet
Répétez ces opérations pour les relations entre les modèles Representation et Reservation.
Définissez entre ces modèles des relations ManyToMany, mais aussi des relations OneToMany si nécessaire.
Par exemple, Representation et Reservation sont en relation ManyToMany mais la table pivot representation_reservation contient en dehors des clés étrangères d’autres informations utiles tel que le prix et la quantité. Vous pouvez dans ce cas remplacer la relation ManyToMany par deux relations ManyToOne. 

•	Versionner le projet

Bravo!
 
Solution partielle	TODO

